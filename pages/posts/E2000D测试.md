---
title: E2000D测试
tags:
  - Linux
categories: Linux
date: 2025-08-19
updated: 2025-08-22
codeHeightLimit: 400
---

### E2000D核心板

1. 测试点基准电压
2. 使用SFLY Flypro对<u>QSPI</u>(W25Q128JVxxQ)行<u>烧录</u>(flash烧写器夹子)`fip-all.bin`  <!-- more -->  
3. 使用WindTerm连接串口,(上电连点回车)设置uboot环境变量

   ```uboot [设置IP]
   setenv serverip 192.168.137.1
   setenv ipaddr 192.168.137.2
   saveenv
   ```

4. 使用Tftpd32传输`ext4`的`Image`和`device tree`串口终端输入命令

   ```uboot [制作临时系统]
   tftpboot 0x90000000 Image
   
   tftpboot 0x92000000 e2000d-demo-board.dtb
   
   setenv bootargs "console=ttyAMA1,115200 earlycon=pl011,0x2800d000"
   #启动临时系统
   booti 0x90000000 - 0x92000000
   ```

5. 临时系统下

   ```bash [emmc分区]
   #当前命令临时系统下在执行
   
   #对emmc系统分区
   fdisk /dev/mmcblk0
   	#按照提示输入
   	#p1
   n
   p
   1
   回车
   +200M
   	#p2
   n
   p
   2
   回车
   回车
   w
   #看下执行结果
   fdisk -l
   #格式化
   mdev -s
   mkfs.vfat /dev/mmcblk0p1
   mkfs.ext4 /dev/mmcblk0p2	#需要输入 y
   sync
   #制作根文件系统
   pwsswd
   mount /dev/mmcblk0p2 /mnt
   cd /mnt
   ls
   ```

6. 打开FileZilla传输`ubunturootfs20250109.tar`,

   本机`192.168.137.1`,板子`192.168.137.222`

   ```bash [制作根文件系统]
   #进行解压
   mv ubunturootfs20250109.tar rootfs.tar
   ls
   tar -xvf rootfs.tar
   #wait a few minutes
   ls
   sync
   cd ..
   umount /mnt
   ```

7. 使用`FileZilla`或者`x86_64-pc-windows-msvc-simple-http-server.exe`配合串口终端烧写`firmware`的`Image`以及设备树`e2000d-demo-board.dtb`

   ```bash [分区1传入firmware, device tree]
   mount /dev/mmcblk0p1 /mnt
   ifconfig eth0 192.168.137.2
   #firmware
   wget -O /mnt/Image http://192.168.137.1:8000/Image
   #device tree
   wget -O /mnt/e2000d-demo-board.dtb http://192.168.137.1:8000/e2000d-demo-board.dtb
   sync
   #查看效果
   cd /mnt
   ls
   cd ..
   umount /mnt
   ```

8. 断电开电重启,连点回车,进入boot系统:

   ``` [固化启动参数]
   #当前为E2000 uboot命令行
   #从emmc启动
   setenv bootargs "console=ttyAMA1,115200 earlycon=pl011, 0x2800d000 root=/dev/mmcblk0p2 rootfstype=ext4 rootwait fsck.mode=force"
   setenv ft_fdt_name "e2000d-demo-board.dtb"
   saveenv
   boot
   #wait
   ```
   
   `root`

   `root`

   ``` [从RAM启动]
   #从RAM启动可以不用网口,可以让其自己解压,仅用供电
   setenv bootargs "console=ttyAMA1,115200 earlycon=pl011, 0x2800d000 root=/dev/ram0 rootfstype=ext4 rootwait fsck.mode=force"
   setenv ft_fdt_name "e2000d-demo-board.dtb"
   boot
   ```

### 反复重启测试

启动后续继续打印 [29] - [33] ,

电源双路合并供电,电压 `5.2V` ,电流 `0.4~0.5A`

### 测试

#### 电气检查

1. 电阻测量
2. 电压测量

#### 功能测试

1. 网络

   ```bash [网络测试]
   ifconfig eth0 192.168.137.222
   #千兆ping
   ping 192.168.137.1
   #千兆收发		cmd下配合
   #	.\iperf3.exe -s
   iperf3 -c 192.168.137.1 -t 100
   iperf3 -c 192.168.137.1 -t 100 -R
   
   #切换网口
   ifconfig eth0 down
   ifconfig eth1 192.168.137.222
   #百兆1 ping
   ping 192.168.137.1
   #百兆1 收发
   iperf3 -c 192.168.137.1 -t 100
   iperf3 -c 192.168.137.1 -t 100 -R
   
   #切换网口
   ifconfig eth1 down
   ifconfig eth2 192.168.137.222
   #百兆2 ping
   ping 192.168.137.1
   #百兆2 收发
   iperf3 -c 192.168.137.1 -t 100
   iperf3 -c 192.168.137.1 -t 100 -R
   ```
  
    ```python [eth_test.py]
    """
    介绍: 使用串口控制电源进行自动化测试E2000核心板网口
    时间: 2025-09-15
    使用方法:
        1. 将电源和 E2000 核心板连接到计算机
        2. 根据网口配置参数 interfaces 设置 Server IP
            eth0 ping_target: 192.168.137.10
            eth1 ping_target: 192.168.137.11
            eth2 ping_target: 192.168.137.12
        3. 运行本脚本
        4. 根据提示选择电源和核心板的串口
        5. 开始测试
    """
    import serial
    import serial.tools.list_ports
    import time
    import re

    class PowerSupplyController:
        def __init__(self, serial_port, baudrate=9600):
            self.serial_port = serial_port
            self.baudrate = baudrate
            self.ser = None

        def connect(self):
            """连接电源串口"""
            try:
                self.ser = serial.Serial(self.serial_port, self.baudrate, timeout=1)
                print(f"已连接到电源串口: {self.serial_port}")
                return True
            except Exception as e:
                print(f"连接电源串口失败: {e}")
                return False

        def disconnect(self):
            """断开电源串口连接"""
            if self.ser and self.ser.is_open:
                self.ser.close()
                print("已断开电源串口连接")

        def send_command(self, command):
            """发送指令到电源并获取响应"""
            try:
                if not self.ser or not self.ser.is_open:
                    print("电源串口未连接")
                    return None

                # 发送指令（以\r\n结尾）
                self.ser.write((command + '\r\n').encode())
                time.sleep(0.1)  # 等待响应

                # 读取响应
                response = b''
                while self.ser.in_waiting > 0:
                    response += self.ser.read(self.ser.in_waiting)
                    time.sleep(0.1)

                return response.decode().strip()
            except Exception as e:
                print(f"发送指令失败: {e}")
                return None

        def set_track_mode(self, mode=2):
            """设置并联模式"""
            print(f"设置并联模式: TRACK{mode}")
            response = self.send_command(f"TRACK{mode}")
            if response:
                print(f"并联模式设置响应: {response}")

        def set_voltage(self, channel, voltage):
            """设置电压"""
            print(f"设置通道 {channel} 电压为: {voltage}V")
            response = self.send_command(f"VSET{channel}:{voltage}")
            if response:
                print(f"电压设置响应: {response}")

        def set_current(self, channel, current):
            """设置电流"""
            print(f"设置通道 {channel} 电流为: {current}A")
            response = self.send_command(f"ISET{channel}:{current}")
            if response:
                print(f"电流设置响应: {response}")

        def get_actual_voltage(self, channel):
            """获取实际电压值"""
            response = self.send_command(f"VOUT{channel}?")
            if response:
                # 移除单位字符,只保留数字部分
                voltage_value = re.sub(r'[^\d.]', '', response)
                print(f"通道 {channel} 实际电压: {voltage_value}V")
                try:
                    return float(voltage_value)
                except ValueError:
                    print(f"无法转换电压值: {response}")
                    return None
            return None

        def get_actual_current(self, channel):
            """获取实际电流值"""
            response = self.send_command(f"IOUT{channel}?")
            if response:
                # 移除单位字符,只保留数字部分
                current_value = re.sub(r'[^\d.]', '', response)
                print(f"通道 {channel} 实际电流: {current_value}A")
                try:
                    return float(current_value)
                except ValueError:
                    print(f"无法转换电流值: {response}")
                    return None
            return None

        def enable_output(self, enable):
            """启用或禁用输出"""
            state = "1" if enable else "0"
            action = "上电" if enable else "下电"
            print(f"{action}")
            response = self.send_command(f"OUT{state}")
            if response:
                print(f"电源输出{action}响应: {response}")


    class BoardController:
        def __init__(self, serial_port, baudrate=115200):
            self.serial_port = serial_port
            self.baudrate = baudrate
            self.ser = None

        def connect(self):
            """连接核心板串口"""
            try:
                self.ser = serial.Serial(self.serial_port, self.baudrate, timeout=1)
                print(f"已连接到核心板串口: {self.serial_port}")
                return True
            except Exception as e:
                print(f"连接核心板串口失败: {e}")
                return False

        def disconnect(self):
            """断开核心板串口连接"""
            if self.ser and self.ser.is_open:
                self.ser.close()
                print("已断开核心板串口连接")

        def wait_for_login_prompt(self, timeout=60):
            """等待核心板输出login:提示符"""
            print("等待核心板启动并输出login:提示符...")
            start_time = time.time()
            buffer = ""

            while time.time() - start_time < timeout:
                if self.ser.in_waiting > 0:
                    data = self.ser.read(self.ser.in_waiting).decode(errors='ignore')
                    buffer += data
                    # print(f"{repr(data)}")  # 打印接收到的数据用于调试

                    # 检查是否包含login:提示符（小写）
                    if "login:" in buffer.lower():
                        print("检测到login:提示符,核心板已启动完成")
                        return True

                time.sleep(0.1)  # 短暂等待后再检查

            print(f"在{timeout}秒内未检测到login:提示符")
            return False

        def send_command(self, command, wait_time=2):
            """发送指令到核心板并获取响应"""
            try:
                if not self.ser or not self.ser.is_open:
                    print("核心板串口未连接")
                    return None

                # 清空缓冲区
                self.ser.reset_input_buffer()

                # 发送指令
                self.ser.write((command + '\n').encode())
                time.sleep(wait_time)  # 等待响应

                # 读取响应
                response = b''
                while self.ser.in_waiting > 0:
                    response += self.ser.read(self.ser.in_waiting)
                    time.sleep(0.1)

                return response.decode().strip()
            except Exception as e:
                print(f"发送指令到核心板失败: {e}")
                return None

        def login(self, username="root", password="root"):
            """登录核心板系统"""
            print(f"尝试登录核心板,用户名: {username}")

            # 发送用户名
            self.ser.write(('\n' + username + '\n').encode())
            time.sleep(1)

            # 发送密码
            print(f"输入密码: {password}")
            self.ser.write((password + '\n').encode())
            time.sleep(1)

            # 检查是否登录成功（发送一个简单命令）
            self.ser.write('echo "Login successful"\n'.encode())
            time.sleep(2)

            # 读取响应
            response = b''
            while self.ser.in_waiting > 0:
                response += self.ser.read(self.ser.in_waiting)
                time.sleep(0.1)

            if response:
                print("登录响应:", response.decode().strip())
                return True
            return False

        def set_ip_and_test(self, interface, ip_address, ping_target):
            """设置IP地址并执行测试"""
            print(f"\n开始测试网口: {interface}")

            # 设置IP地址
            print(f"设置 {interface} IP地址为: {ip_address}")
            self.send_command(f"ifconfig {interface} {ip_address}", wait_time=2)

            # 执行ifconfig命令
            print("执行ifconfig命令")
            self.send_command("ifconfig", wait_time=2)
            time.sleep(3)

            # 执行ping测试
            print(f"执行ping测试,目标: {ping_target}")
            ping_response = self.send_command(f"ping -c 5 {ping_target}", wait_time=10)

            # 检查ping结果
            ping_success = False
            if ping_response:
                print(f"Ping响应: {ping_response}")
                packet_loss_match = re.search(r'(\d+)% packet loss', ping_response)
                if packet_loss_match:
                    packet_loss = int(packet_loss_match.group(1))
                    ping_success = (packet_loss == 0)

            # 如果ping成功,down掉网口
            if ping_success:
                print(f"Ping测试成功,down掉 {interface}")
                self.send_command(f"ifconfig {interface} down", wait_time=2)
            else:
                print(f"Ping测试失败,但仍down掉 {interface},继续进行测试")
                self.send_command(f"ifconfig {interface} down", wait_time=2)

            return ping_success


    def list_serial_ports():
        """列出所有可用的串口"""
        ports = serial.tools.list_ports.comports()
        if not ports:
            print("未找到可用的串口设备")
            return []

        print("可用的串口设备:")
        for i, port in enumerate(ports):
            print(f"{i + 1}. {port.device} - {port.description}")

        return [port.device for port in ports]


    def select_serial_port(ports, purpose):
        """让用户选择串口"""
        if not ports:
            return None

        while True:
            try:
                choice = input(f"请选择用于{purpose}的串口编号 (1-{len(ports)}): ")
                index = int(choice) - 1
                if 0 <= index < len(ports):
                    return ports[index]
                else:
                    print(f"请输入有效的编号 (1-{len(ports)})")
            except ValueError:
                print("请输入有效的数字")


    def main():
        # 列出所有可用的串口
        available_ports = list_serial_ports()
        if not available_ports:
            return

        # 让用户选择电源串口
        power_serial_port = select_serial_port(available_ports, "电源")
        if not power_serial_port:
            return

        # 让用户选择核心板串口
        board_serial_port = select_serial_port(available_ports, "核心板")
        if not board_serial_port:
            return

        # 配置参数
        voltage = 5.0  # 电压值
        current = 2.0  # 电流值
        channel = 1  # 电源通道
        username = "root"  # 核心板登录用户名
        password = "root"  # 核心板登录密码

        # 网口配置
        interfaces = [
            {"name": "eth0", "ip": "192.168.137.220", "ping_target": "192.168.137.10"},
            {"name": "eth1", "ip": "192.168.137.221", "ping_target": "192.168.137.11"},
            {"name": "eth2", "ip": "192.168.137.222", "ping_target": "192.168.137.12"}
        ]

        # 创建电源控制器
        power_supply = PowerSupplyController(power_serial_port)

        # 创建核心板控制器
        board = BoardController(board_serial_port)

        try:
            # 连接电源串口
            if not power_supply.connect():
                return

            # 设置并联模式
            power_supply.set_track_mode(2)

            # 设置电压和电流
            power_supply.set_voltage(channel, voltage)
            power_supply.set_current(channel, current)

            # 进行两次测试
            for test_count in range(1, 3):
                print(f"\n开始第 {test_count} 次测试")

                # 上电
                power_supply.enable_output(True)

                # 查询实际电压和电流
                power_supply.get_actual_voltage(channel)
                power_supply.get_actual_current(channel)

                # 连接核心板串口    如果连接失败,下电并退出
                if not board.connect():
                    power_supply.enable_output(False)
                    return

                # 等待核心板启动并输出login:提示符
                if not board.wait_for_login_prompt(timeout=60):
                    print("等待login:提示符超时")
                    return

                # 登录核心板
                if not board.login(username, password):
                    print("登录核心板失败,程序终止")
                    return

                time.sleep(10)  # 为在进行ping时避开“[32.xxx]xxx”未检测到设备
                # 测试所有网口
                results = {}
                for interface in interfaces:
                    # 测试网口
                    success = board.set_ip_and_test(
                        interface["name"],
                        interface["ip"],
                        interface["ping_target"]
                    )
                    results[interface["name"]] = success

                # 断开核心板串口
                board.disconnect()

                # 下电
                power_supply.enable_output(False)

                # 输出测试结果
                print(f"\n第 {test_count} 次测试结果:")
                for interface, success in results.items():
                    status = "成功" if success else "失败"
                    print(f"{interface}: {status}")

                # 如果不是最后一次测试,等待20秒
                if test_count < 2:
                    print("等待20秒后进行下一次测试...")
                    time.sleep(20)

            print("\n测试结束!")

        except KeyboardInterrupt:
            print("程序被用户中断")
        except Exception as e:
            print(f"程序执行出错: {e}")
        finally:
            # 确保下电并断开连接
            board.disconnect()
            power_supply.enable_output(False)
            power_supply.disconnect()

    if __name__ == "__main__":
        main()
    ```



2. GPIO

   ```bash [GPIO测试]
   cd /home/user/work/gpio_test
   ls
   vim gpio_test.c
   #修改一下内容
   gcc gpio_test.c -o gpio_test
   ./gpio_test 470 out 1
   #依次修改各引脚高低电平	测量记录
   ```

   | 控制号 | 插座位置 | 输出高电平 | 输出低电平 |
   | ------ | -------- | ---------- | ---------- |
   | 470    | J1A-6    | 3.298      | 0.018      |
   | 467    | J1B-8    | 3.301      | 0.01       |
   | 497    | J1B-9    | 3.298      | 0.001      |
   | 475    | J1C-6    | 3.298      | 0.001      |
   | 476    | J1C-7    | 3.298      | 0.001      |
   | 477    | J1C-8    | 3.298      | 0.001      |
   | 469    | J1C-9    | 3.298      | 0.018      |
   | 478    | J1D-4    | 3.3        | 0.001      |

   稍作改动,一次性对 `position_map` 中的GPIO置位   
    ```C [my_gpio_test.c]
    #include <fcntl.h>
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <unistd.h>

    #define GPIO_NUM 8

    static char gpio_path[100];
    char file_path[200];
    int fd;
    int len;
    const char *position_map[GPIO_NUM][2] = {
        {"470", "J1A-6"}, {"467", "J1B-8"}, {"497", "J1B-9"}, {"475", "J1C-6"},
        {"476", "J1C-7"}, {"477", "J1C-8"}, {"469", "J1C-9"}, {"478", "J1D-4"}};

    static int gpio_config(const char *attr, const char *val) {
      sprintf(file_path, "%s/%s", gpio_path, attr);
      if (0 > (fd = open(file_path, O_WRONLY))) {
        perror("open error");
        return fd;
      }

      len = strlen(val);
      if (len != write(fd, val, len)) {
        perror("write error");
        close(fd);
        return -1;
      }

      close(fd);
      return 0;
    }

    int Import_File(const char *val) {
      sprintf(gpio_path, "/sys/class/gpio/gpio%s", val);
      if (access(gpio_path, F_OK)) {
        if (0 > (fd = open("/sys/class/gpio/export", O_WRONLY))) {
          perror("open error");
          return 0;
        }
        len = strlen(val);
        if (len != write(fd, val, len)) {
          perror("write error");
          close(fd);
          return 0;
        }
        close(fd);
        printf("The GPIO%s create success!\n", val);
      } else {
        printf("The GPIO%s already exists!\n", val);
      }
      // explain the gpio position
      for (int i = 0; i < GPIO_NUM; i++) {
        if (strcmp(val, position_map[i][0]) == 0) {
          printf("(The GPIO%s is %s)\n", val, position_map[i][1]);
          break;
        }
      }
      return 0;
    }

    void Get_GPIO_Value(void) {
      char val;
      sprintf(file_path, "%s/%s", gpio_path, "value");

      if (0 > (fd = open(file_path, O_RDONLY))) {
        perror("open error");
        exit(-1);
      }

      if (0 > read(fd, &val, 1)) {
        perror("read error");
        close(fd);
        exit(-1);
      }
      printf("value: %c\n", val);
    }

    int gpio_test(int argc, char *argv[]) {
      if (argc != 3 && argc != 4) {
        fprintf(stderr, "usage: %s <gpio> <out> <value>\n", argv[0]);
        fprintf(stderr, "usage: %s <gpio> <in>\n", argv[0]);
        return -1;
      } else {
        Import_File(argv[1]);
        if ((strcmp(argv[2], "in") == 0) && argc == 3) {
          Get_GPIO_Value();
        } else if ((strcmp(argv[2], "out") == 0) && argc == 4) {
          if (gpio_config("direction", argv[2])) return -1;
          if (gpio_config("active_low", "0")) return -1;
          if (gpio_config("value", argv[3])) return -1;
          Get_GPIO_Value();
        } else {
          fprintf(stderr, "usage: %s <gpio> <out> <value>\n", argv[0]);
          fprintf(stderr, "usage: %s <gpio> <in>\n", argv[0]);
          return -1;
        }
      }
      return 0;
    }

    int my_gpio_test(char *value) {
      // put these gpio pin to 0 or 1 together
      char *gpio_pin[] = {"470", "467", "497", "475", "476", "477", "469", "478"};
      for (int i = 0; i < GPIO_NUM; i++) {
        Import_File(gpio_pin[i]);
        if (gpio_config("direction", "out")) return -1;
        if (gpio_config("active_low", "0")) return -1;
        if (gpio_config("value", value)) return -1;
        Get_GPIO_Value();
      }
      return 0;
    }
    /*
    * Usage:
    * ./my_gpio_test 0
    * ./my_gpio_test 1
    */
    int main(int argc, char *argv[]) {
      /*
      // original gpio_test
      int ret = gpio_test(argc, argv);
      exit(ret);
      */
      int ret = 0;
      if (argc != 2) {
        fprintf(stderr, "usage: %s <gpio> <out> <value>\n", argv[0]);
        fprintf(stderr, "usage: %s <gpio> <in>\n", argv[0]);
        exit(-1);
      } else {
        // according to the value of argv[1], set the gpio pin to 0 or 1
        if (strcmp(argv[1], "0") == 0) {
          ret = my_gpio_test("0");
        } else if (strcmp(argv[1], "1") == 0) {
          ret = my_gpio_test("1");
        } else {
          fprintf(stderr, "usage: %s <gpio> <out> <value>\n", argv[0]);
          fprintf(stderr, "usage: %s <gpio> <in>\n", argv[0]);
          exit(-1);
        }
        exit(ret);
      }
      return 0;
    }
    ```

3. PWM测试

   ```bash [PWM测试]
   #写入pwm参数
   echo 0 > /sys/class/pwm/pwmchip0/export
   echo 1000000 > /sys/class/pwm/pwmchip0/pwm0/period
   echo 500000 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle
   echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable
   #连接示波器查看参数	引脚 J1 D9
   #改参数
   echo 300000 > /sys/class/pwm/pwmchip0/duty_cycle
   ```

4. I2C-RTC测试

   ```bash [I2C-RTC测试]
   date -s "2024-10-06 22:20:59"
   hwclock -w
   hwclock -r
   hwclock -s
   hwclock --show
   ```

5. PCIE测试

   ```bash [PCIE测试]
   lspci
   lspci -v
   ```

6. EMMC测试

   ```bash [EMMC测试]
   lsblk
   #查看mmcblk0
   fdisk /dev/mmcblk0
   p
   q
   ```

7. SD卡测试

   ```bash [SD卡测试]
   lsblk
   #查看mmcblk1
   fdisk /dev/mmcblk1
   p
   q
   ```

8. SOC温度测试

   ```bash [SOC温度测试]
   sensors
   #OR
   cat /sys/class/hwmon/hwmon2/temp1_input
   cat /sys/class/hwmon/hwmon2/temp2_input
   ```

9. SATA测试

   ```bash [SATA测试]
   lsblk
   #查看sda
   fdisk /dev/sda
   p
   q
   ```

10. 内存压力测试

    ```bash [内存压力测试]
    tar -xzvf memtester-4.7.1.tar.gz
    cd memtester-4.7.1
    make
    make install
    #memtester 1G 2 loops
    memtester 1024 2 | tee -a memtester.log
    ```

11. 共享网络

    ```bash [共享网络]
    #先在主机控制面板里WLAN打开共享
    route add default gw 192.168.137.1 dev eth0
    resolvectl dns eth0 192.168.137.1
    ping bing.com
    ```


